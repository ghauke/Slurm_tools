#!/usr/bin/env bash

# Summarize TOP USER accounting information from Slurm sacct accounting records
# Author:	Ole.H.Nielsen@fysik.dtu.dk
# Homepage: https://github.com/OleHolmNielsen/Slurm_tools/

#####################################################################################
#
# Command usage:
#
function usage()
{
	cat <<EOF
Usage: slurmacct [-s Start_time -e End_time | -c | -y | -w | -l | -m monthyear] [-p partition(s)] [-u username] [-g groupname] [-G] [-W workdir] [-r report-prefix] [-n] [-Q] {-N} [-h]
where:
	-s Start_time [last month]: Starting time of accounting period.
	-e End_time [last month]: End time of accounting period.
	-c: Current month
	-y: Current year
	-w: Last week
	-l: Last year
	-m monthyear: Select month and year (like "november2019")
	-p partition(s): Select only Slurm partion <partition>[,partition2,...]
	-t tres/gpu: Print TRES information, especially GPU
	-u username: Print only user <username> 
	-g groupname: Print only users in UNIX group <groupname>
	-G: Print only groupwise summed accounting data
	-W directory: Print only jobs with this string in the job WorkDir
	-r: Report name prefix
	-n: No header information is printed
	-P: Parsable
	-Q: Print queue (waiting times) statistics
	-N: Print job node statistics
	-h: Print this help information

The Start_time and End_time values specify the date/time interval of
job completion/termination (see "man sacct").

Hint: Specify Start/End time as MMDD (Month and Date)
EOF
}

#####################################################################################

# Report file prefix
REPORT_PREFIX=/tmp/Slurm_report_acct_
export partition=""
export username=""
export groupname=""
export workdir=""
export ALLGROUPS=0
export SORTCOLUMN=5
export printheader=1
export month="last"

# Process options
while getopts "p:u:g:s:e:r:m:W:cywlGhntPQJ" options; do
	case $options in
		p )     export partition=$OPTARG
			echo Print only accounting in Slurm partition $OPTARG
			;;
		u )     export username=$OPTARG
			export ALLGROUPS=0
			echo Print only user $OPTARG
			;;
		g )     export groupname="$OPTARG"
			export ALLGROUPS=0
			export SORTCOLUMN=5
			echo Print only users in UNIX group $OPTARG
			;;
		G )     export ALLGROUPS=1
			export username=""
			export groupname=""
			export SORTCOLUMN=4
			echo Print only groupwise summed accounting data
			;;
		s )     export start_time=$OPTARG
			echo Start date $OPTARG
			REPORT_NAME=${start_time}_${end_time}
			;;
		e )     export end_time=$OPTARG
			echo End date $OPTARG
			REPORT_NAME=${start_time}_${end_time}
			;;
		m )     echo Select month $OPTARG 
			start_time=`date -d "1$OPTARG" +%m01%y`
			end_time=`date -d "1$OPTARG + 1 month" +%m01%y`
			YEARMONTH=`date -d "1$OPTARG" +%Y-%m`
			REPORT_NAME=${YEARMONTH}
			;;
		c )     export start_time=`date +%m01%y`
			export end_time=`date +%m%d%y`
			echo Select current month from $start_time until $end_time
			REPORT_NAME=Current_month
			;;
		y )     export start_time=`date +0101%y`
			export end_time=`date +%m%d%y`
			echo Select current year from $start_time until $end_time
			REPORT_NAME=Current_year
			;;
		l )     export start_time=`date -d "last year" +0101%y`
			export end_time=`date +0101%y`
			echo Select last year from $start_time until $end_time
			REPORT_NAME=Last_year
			;;
		w )     export start_time=`date -d 'last week' +%m%d%y`
			export end_time=`date +%m%d%y`
			echo Select last week from $start_time until $end_time
			REPORT_NAME=Last_week
			;;
		W )     export workdir=$OPTARG
			echo Print only accounting data for jobs with working directory $workdir
			;;
		r )     export REPORT_PREFIX="$OPTARG"
			echo Copy report to $OPTARG
			;;
		n )     export printheader=0
			;;
		P )     export parsable=1
			;;
		t )     export tresgpu=1
			;;
		Q )     export stats=1
			;;
		N )     export nodestats=1
			;;
		h|? ) usage
			exit 1;;
		* ) usage
			exit 1;;
	esac
done
shift $((OPTIND-1))

#
# Default period: last month 
#
# Test if either start_time or end_time are empty strings
if test -z "$start_time" -o -z "$end_time"
then
	YEARMONTH=`date -d "last month" +%Y-%m`
	REPORT_NAME=${YEARMONTH}
	start_time=`date -d "last month" +%m01%y`
	end_time=`date -d "last month + 1 month" +%m01%y`
fi

# Check partition names
if test -n "$partition"
then
	for p in `echo $partition | sed 's/,/ /g'`
	do
		# echo "Check partition $p"
	if test -z "`sinfo -h -p $p -O PartitionName`" 
	then
			echo "WARNING: Invalid partition name $p"
			# echo "Valid partition names are:"
			# sinfo -O "PartitionName"
		fi
	done
fi

# Test username
if test -n "$username" 
then
	if test -z "`sacctmgr -p -n show assoc where users=$username`"
	then
		echo Error selecting Slurm username $username 
		exit -1
	fi
fi
# Test groupname
if test -n "$groupname"
then
	getent group $groupname > /dev/null
	if test "$?" -ne 0
	then
		echo "Error selecting UNIX groupname $groupname (it does not exist)"
		exit -1
	fi
fi

#####################################################################################
#
# Print a heading, and make selection for sacct report
#
# First report overall statistics including nicely formatted start/end date:
# Change the date/time format in report header for readibility (formats in "man strftime")

REPORT=${REPORT_PREFIX}${REPORT_NAME}

export SLURM_TIME_FORMAT="%d-%b-%Y_%R"

# Selections for sacct:
selection=""

# Print a report header

if test $printheader -gt 0
then
	# Print a sreport header (overwrite any existing file)
	# Print all TRES if statistics are shown for the whole cluster
	if test -n "$tresgpu"
	then
		if test -n "$partition"
		then
			tres="gres/gpu"
		else
			tres="ALL"
		fi
	else
		tres=""
		timeformat="percent"
	fi
	sreport cluster utilization start=$start_time end=$end_time -t ${timeformat:-hourper} Format=Cluster,Allocated,Planned,Idle,PlannedDown,Down,Reported${tres:+,TresName} ${tres:+--tres="$tres"} ${parsable:+-p}  > $REPORT
fi

# Request of a specific partition
if test -n "$partition"
then
	echo >> $REPORT
	echo Partition selected: $partition >> $REPORT
	selection="--partition $partition $selection"
fi

# Wallclock hours are the total for the reserved cpus per job
# Average runtime describes the job runtime.

if test $ALLGROUPS -eq 0
then
	# User statistics
	echo >> $REPORT
	if test -n "$workdir"
	then
		echo "Print only accounting data for jobs with working directory $workdir" >> $REPORT
		echo >> $REPORT
	fi
	echo Usage sorted by top users: >> $REPORT
	# echo "Jobs completed/terminated between date/time $start_time and $end_time"
	if test -n "$username"
	then
		echo "User name selected: $username" >> $REPORT
		selection="--user $username $selection"
	else
		# Select all users
		selection="-a $selection"
	fi
	if test -n "$groupname"
	then
		echo "Group name selected: $groupname" >> $REPORT
		selection="--group $groupname $selection"
	fi
	# echo "                             Wallclock          Average Average" >> $REPORT
	# echo "Username    Group    #jobs       hours  Percent  #cpus  q-hours  Full name" >> $REPORT
	# echo "--------    -----  ------- -----------  ------- ------- -------  ---------" >> $REPORT
if test -n "$parsable"
then
	echo "Username|Group|#jobs|Wallclock hours|Percent|Average #gpus|Average #cpus|${tresgpu:+Average #gpus|}Average runtime|Average Requested Time|Average q-hours|Full name${stats:+|Perfect Jobs|Total Waiting|TW30m|TW1h|TW2h|TW3h|TW6h|TW12h|TW1d|TW2d|TW3d|TW5d|TW7d|1 Node Jobs|2 Node Jobs|3 Node Jobs|4 Node Jobs|5 Node Jobs|6+ Node Jobs}" >> $REPORT
else
cat <<EOF >> $REPORT
                             Wallclock           Energy Average   Average ${tresgpu:+Average }Average Average Average
Username    Group    #jobs       hours  Percent    kWh  #nodes      #cpus ${tresgpu:+  #gpus }runtime ReqTime q-hours Full name              ${stats:+Perfect TW     TW30m  TW1h   TW2h   TW3h   TW6h   TW12h  TW1d   TW2d   TW3d   TW5d   TW7d    1Node  2Node  3Node  4Node  5Node  6+Node}
--------    -----  ------- -----------  ------- ------- ------- --------- ${tresgpu:+------- }------- ------- ------- ---------------------- ${stats:+------- ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------  ------ ------ ------ ------ ------ ------}
EOF
fi
else
	# Group statistics
	echo >> $REPORT
	if test -n "$workdir"
	then
		echo "Print only accounting data for jobs with working directory $workdir" >> $REPORT
		echo >> $REPORT
	fi
	echo Usage sorted by top groups: >> $REPORT
	# echo "Jobs completed/terminated between date/time $start_time and $end_time"
	if test -n "$parsable"
	then
		echo "Group|#jobs|Wallclock hours|Percent|Average #gpus|Average #cpus|${tresgpu:+Average #gpus|}Average runtime|Average Requested Time|Average q-hours${stats:+|TW30m|TW1h|TW2h|TW3h|TW6h|TW12h|TW1d|TW2d|TW3d|TW5d|TW7d}" >> $REPORT
	else
		echo "                    Wallclock          Average   Average ${tresgpu:+Average }Average Average Average" >> $REPORT
		echo "   Group    #jobs       hours  Percent  #nodes     #cpus ${tresgpu:+  #gpus }runtime ReqTime q-hours ${stats:+TW30m  TW1h   TW2h   TW3h   TW6h   TW12h   TW1d   TW2d   TW3d   TW5d   TW7d}" >> $REPORT
		echo "   -----  ------- -----------  ------- ------- --------- ${tresgpu:+------- }------- ------- ------- ${stats:+------ ------ ------ ------ ------ ------ ------ ------ ------ ------ ------}" >> $REPORT
	fi
fi

#####################################################################################
#
# Get and process Slurm accounting records

# Get length of strings for sacct formatting
if test -n "$usernamelength"
then
	ulen="%${#username}"
fi
if test -n "$groupnamelength"
then
	glen="%${#groupname}"
fi

# Report time in seconds:
export SLURM_TIME_FORMAT="%s"
# Request job data
export FORMAT="JobID,User${ulen},Group${glen},Partition,AllocNodes,AllocCPUS,Submit,Eligible,Start,End,ElapsedRAW,CPUTimeRAW,State,ConsumedEnergyRaw,WorkDir,TimelimitRaw,ReqTRES"
# Request job states: CAncelled, ReQueued, CompleteD, Failed, TimeOut, PReempted, Out_Of_Memory
export STATE="ca,rq,cd,f,to,pr,oom"

# Get Slurm individual job accounting records using the "sacct" command
# The "-a" flag was removed 04-Jan-2023
# -X: Only show statistics relevant to the job allocation itself, not taking steps into consideration.
sacct $selection -np -X -S $start_time -E $end_time -o $FORMAT -s $STATE | awk -v parsable="$parsable" -v tresgpu="$tresgpu" -v stats="$stats" -F"|" '
BEGIN {
	userselect=ENVIRON["username"]
	groupselect=ENVIRON["groupname"]
	ALLGROUPS=ENVIRON["ALLGROUPS"]
	workdir=ENVIRON["workdir"]
	totaljobs=0
	totalreqgpu=0
	totalwait30m=0
	totalwait1h=0
	totalwait2h=0
	totalwait3h=0
	totalwait6h=0
	totalwait12h=0
	totalwait1d=0
	totalwait2d=0
	totalwait3d=0
	totalwait5d=0
	totalwait7d=0
	totalnodes1=0
	totalnodes2=0
	totalnodes3=0
	totalnodes4=0
	totalnodes5=0
	totalnodesM=0
	giga=1000000000
	# Maximum possible node power
	maxpower = 5000
	kWh=3600000	# 1 kWh is this many Joules
	# First get the list of user full names from /etc/passwd lines
	COMMAND="getent passwd"
	while (COMMAND | getline ) {
		split($0,b,":")		# Split password line into fields
		fullname[b[1]] = b[5]	# Full name b[5] of this username (b[1])
		# print b[1], fullname[b[1]]
	}
	close(COMMAND)
}
{
	# Parse input data and make sanity checks
	JobID	= $1		# JobID
	cput	= $11		# CPU time in seconds
	if (cput <= 0) next	# Skip jobs with zero cputime
	user	= $2		# User name
	group	= $3		# Group name
	part	= $4		# Slurm partition name for this job
	nodect	= $5		# Number of nodes used
	total_ncpus = $6	# Total number of CPUs used (>=nodect)
	submit	= $7		# submit time
	eligible= $8		# eligible time
	if (eligible == "Unknown") eligible = submit
	start	= $9		# Job start time in epoch seconds
	end	= $10		# Job end time in epoch seconds
	elapsed	= $11		# Job elapsed time in seconds
	cputime	= $12		# CPU time in seconds
	if (start == "Unknown" || start == "None") start = end
	state	= $13		# Job state
	wall	= end - start
	wait	= start - eligible
	if (wait < 0) wait = 0	# Should not happen
	# Total energy consumed by a job, in joules. 
	# BEWARE: If multiple jobs share a node, we cannot assign an energy to individual jobs!
	joules	= $14
	# Incorrect astronomically large joules numbers may occur, see https://support.schedmd.com/show_bug.cgi?id=20207
	if (joules == "" || joules > 10*giga) joules = 0
	# Check sanity of power (joules/elapsed) must be less than maxpower Watts
	power = joules / elapsed
	if (power > maxpower) joules = 0
	jobworkdir	= $15	# Job working directory
	jobtimelimit	= $16	# Job time limit in minutes
	jobreqtres	= $17	# Requestes TRES

# Parse requested TRES data and save requested GPU amount
# Example: (add single quotes aroung {} after awk) - sums all gpu res, but not necessary, as slurm summarizes it already with gres/gpu
# echo "billing=72,cpu=72,gres/gpu=1,gres/gpu:a100=2,gres/gpu:l40s=8,mem=245000M,node=3" | awk {n = split($0,a,","); gpus = 0; for (i in a) {match(a[i], /gres\/gpu[a-z,:,[:digit:]]*=([[:digit:]]+)/,g);gpus+=g[1]}; print gpus}
	match(jobreqtres, /gres\/gpu=([[:digit:]]+)/,a)
	jobreqgpu = a[1]

	jobnodes = nodect
	# For accounting by number of CPU cores in stead of number of nodes,
	# uncomment the following line:
	nodect = total_ncpus

	# TOTAL accounting
	totaljobs++
	totalwait += wait
	cpunodesecs += nodect*cput
	wallnodesecs += nodect*wall
	wallsecs += wall
	totalnodes += jobnodes
	totaltimelimit += jobtimelimit
	totalreqgpu += jobreqgpu
	# waiting jobs clustering
	if (stats > 0) {
		if (wait > (10080*60)) {
			totalwait7d++
			wait7d[user,group]++
			gr_wait7d[group]++
		} else if (wait > (7200*60)) {
			totalwait5d++
			wait5d[user,group]++
			gr_wait5d[group]++
		} else if (wait > (4320*60)) {
			totalwait3d++
			wait3d[user,group]++
			gr_wait3d[group]++
		} else if (wait > (2880*60)) {
			totalwait2d++
			wait2d[user,group]++
			gr_wait2d[group]++
		} else if (wait > (1440*60)) {
			totalwait1d++
			wait1d[user,group]++
			gr_wait1d[group]++
		} else if (wait > (720*60)) {
			totalwait12h++
			wait12h[user,group]++
			gr_wait12h[group]++
		} else if (wait > (360*60)) {
			totalwait6h++
			wait6h[user,group]++
			gr_wait6h[group]++
		} else if (wait > (180*60)) {
			totalwait3h++
			wait3h[user,group]++
			gr_wait3h[group]++
		} else if (wait > (120*60)) {
			totalwait2h++
			wait2h[user,group]++
			gr_wait2h[group]++
		} else if (wait > (60*60)) {
			totalwait1h++
			wait1h[user,group]++
			gr_wait1h[group]++
		} else if (wait > (30*60)) {
			totalwait30m++
			wait30m[user,group]++
			gr_wait30m[group]++
		} else {
			totalperfectjobs++
			perfectjobs[user,group]++
			gr_perfectjobs[group]++
		}
	}
	#allocated nodes counting
	if (jobnodes > 5) {
		totalnodesM++
		nodesM[user,group]++
		gr_nodesM[group]++
	} else if (jobnodes == 5) {
		totalnodes5++
		nodes5[user,group]++
		gr_nodes5[group]++
	} else if (jobnodes == 4) {
		totalnodes4++
		nodes4[user,group]++
		gr_nodes4[group]++
	} else if (jobnodes == 3) {
		totalnodes3++
		nodes3[user,group]++
		gr_nodes3[group]++
	} else if (jobnodes == 2) {
		totalnodes2++
		nodes2[user,group]++
		gr_nodes2[group]++
	} else {
		totalnodes1++
		nodes1[user,group]++
		gr_nodes1[group]++
	}

	# Check if this job matches selection criteria
	if (userselect != "" && user != userselect) next
	if (groupselect != "" && group != groupselect) next
	if (workdir != "" && jobworkdir !~ workdir) next

	# User accounting (a user may belong to several groups)
	usernamegroup[user,group] = user
	fullnamegroup[user,group] = fullname[user]
	usergroup[user,group] = group
	jobs[user,group]++
	cpunodes[user,group] += nodect*cput
	wallnodes[user,group] += nodect*wall
	wallcpu[user,group] += wall
	joulesused[user,group] += joules
	if (nodect < minnodes[user,group]) minnodes[user,group] = nodect
	if (nodect > maxnodes[user,group]) maxnodes[user,group] = nodect
	waittime[user,group] += wait
	nodes[user,group] += jobnodes
	timelimit[user,group] += jobtimelimit
	reqgpu[user,group] += jobreqgpu

	# Group accounting
	groupname[group]=group
	gr_jobs[group]++
	gr_cpunodes[group] += nodect*cput
	gr_wallnodes[group] += nodect*wall
	gr_wallcpu[group] += wall
	if (nodect < gr_minnodes[group]) gr_minnodes[group] = nodect
	if (nodect > gr_maxnodes[group]) gr_maxnodes[group] = nodect
	gr_waittime[group] += wait
	gr_nodes[group] += jobnodes
	gr_timelimit[group] += jobtimelimit
	gr_reqgpu[group] += jobreqgpu
	groupjoulesused[group] += joules
	totaljoules += joules
} END {
	# Some average values
	if (totaljobs > 0) {
		totalwaitaverage = totalwait/totaljobs
		totalwallaverage = wallsecs/totaljobs
		totaltimelimitaverage = totaltimelimit/totaljobs
		totalnodesaverage = totalnodes/totaljobs
		totalreqgpuaverage = totalreqgpu/totaljobs
		totalwaitingjobs = totaljobs-totalperfectjobs
	}
	else {
		totalwaitaverage = 0
		totalwallaverage = 0
		totaltimelimitaverage = 0
		totalnodesaverage = 0
		totalreqgpu = 0
	}
	if (wallsecs > 0)
		nodesaverage = wallnodesecs/wallsecs
	else
		nodesaverage = 0
	# Usage in hours
	cpunodehours = cpunodesecs / 3600
	wallnodehours = wallnodesecs / 3600
	wallhours = wallsecs / 3600
	if (totaljobs == 0 || cpunodehours == 0 || wallnodehours == 0 || wallhours == 0) {
		# print "ERROR: Zero CPU hours recorded in specified date interval"
		# print "totaljobs = ", totaljobs, "cpunodehours = ", cpunodehours, "wallnodehours = ", wallnodehours, "wallhours = ", wallhours
		# exit 1
	}

	if (ALLGROUPS == 0) {

		# Print format
		if (tresgpu > 0)
			format = "%8.8s %8.8s %8d  %10.1f  %7.2f %7.0f %7.2f %9.2f %7.2f %7.2f %7.2f %7.2f  %20s\n"
		else
			format = "%8.8s %8.8s %8d  %10.1f  %7.2f %7.0f %7.2f %9.2f %7.2f %7.2f %7.2f  %20s\n"
		if (stats > 0) format = gensub(/\n$/,"","G",format) " %8d %6d %6d %6d %6d %6d %6d %6d %6d %6d %6d %6d %6d  %6d %6d %6d %6d %6d %6d\n" #TODO separate Q and N parameter
		if (parsable > 0) format = gensub(/\s+/,"|","G",format) "\n" #TODO
		groupjobs = 0
		groupnodes = 0
		grouphours = 0
		grouptimelimit = 0
		groupjoules = 0
		for (ug in usernamegroup) {
			if (length(groupselect) > 0 && usergroup[ug] != groupselect) continue
			if (wallnodehours > 0 && jobs[ug] > 0 && wallcpu[ug] > 0)
				if (tresgpu > 0)
					printf(format, usernamegroup[ug], usergroup[ug],
					jobs[ug],
					wallnodes[ug]/3600,
					100*wallnodes[ug]/(wallnodehours*3600),
					joulesused[ug]/kWh,
					nodes[ug]/jobs[ug],
					wallnodes[ug]/wallcpu[ug],
					reqgpu[ug]/jobs[ug],
					wallcpu[ug]/jobs[ug]/3600,
					timelimit[ug]/jobs[ug]/60,
					waittime[ug]/jobs[ug]/3600,
					fullnamegroup[ug],
					perfectjobs[ug],
					jobs[ug]-perfectjobs[ug],
					wait30m[ug], wait1h[ug], wait2h[ug], wait3h[ug], wait6h[ug], wait12h[ug],
					wait1d[ug], wait2d[ug], wait3d[ug], wait5d[ug], wait7d[ug],
					nodes1[ug],nodes2[ug],nodes3[ug],nodes4[ug],nodes5[ug],nodesM[ug])
				else
					printf(format, usernamegroup[ug], usergroup[ug],
						jobs[ug],
						wallnodes[ug]/3600,
						100*wallnodes[ug]/(wallnodehours*3600),
						joulesused[ug]/kWh,
						nodes[ug]/jobs[ug],
						wallnodes[ug]/wallcpu[ug],
						wallcpu[ug]/jobs[ug]/3600,
						timelimit[ug]/jobs[ug]/60,
						waittime[ug]/jobs[ug]/3600,
						fullnamegroup[ug]i,
						perfectjobs[ug],
						jobs[ug]-perfectjobs[ug],
						wait30m[ug], wait1h[ug], wait2h[ug], wait3h[ug], wait6h[ug], wait12h[ug],
						wait1d[ug], wait2d[ug], wait3d[ug], wait5d[ug], wait7d[ug],
						nodes1[ug],nodes2[ug],nodes3[ug],nodes4[ug],nodes5[ug],nodesM[ug])
			groupjobs += jobs[ug]
			groupnodes += nodes[ug]
			groupnodehours += wallnodes[ug]/3600
			groupreqgpu += reqgpu[ug]
			grouphours += wallcpu[ug]/3600
			grouptimelimit += timelimit[ug]/60
			groupwait += waittime[ug]
			groupjoules += groupjoulesused[ug]
			usercount++
		}
		# Print out total usage
		totalusers = "Number of users: " usercount
		if (tresgpu > 0)
			printf(format, "TOTAL", "(All)", totaljobs, wallnodehours, 100, totaljoules/kWh,
				totalnodesaverage, nodesaverage, totalreqgpuaverage, totalwallaverage/3600, totaltimelimitaverage/60,
				totalwaitaverage/3600, totalusers,
				totalperfectjobs, totalwaitingjobs,
				totalwait30m, totalwait1h, totalwait2h, totalwait3h, totalwait6h, totalwait12h,
				totalwait1d, totalwait2d, totalwait3d, totalwait5d, totalwait7d,
				totalnodes1,totalnodes2,totalnodes3,totalnodes4,totalnodes5,totalnodesM)
		else
			printf(format, "TOTAL", "(All)", totaljobs, wallnodehours, 100, totaljoules/kWh,
				totalnodesaverage, nodesaverage, totalwallaverage/3600, totaltimelimitaverage/60,
				totalwaitaverage/3600, totalusers,
				totalperfectjobs, totalwaitingjobs,
				totalwait30m, totalwait1h, totalwait2h, totalwait3h, totalwait6h, totalwait12h,
				totalwait1d, totalwait2d, totalwait3d, totalwait5d, totalwait7d,
				totalnodes1,totalnodes2,totalnodes3,totalnodes4,totalnodes5,totalnodesM)
		# Print out group usage
		if (length(groupselect) > 0 && groupjobs > 0 && wallnodehours > 0 && grouphours > 0)
			if (tresgpu > 0)
				printf(format,
					"GROUP", groupselect, groupjobs, groupnodehours,
					100*groupnodehours/wallnodehours, groupjoules/kWh,
					groupnodes/groupjobs, groupnodehours/grouphours,
					groupreqgpu/groupjobs,
					grouphours/groupjobs, grouptimelimit/groupjobs/60,
					groupwait/groupjobs/3600, "")
			else
				printf(format,
					"GROUP", groupselect, groupjobs, groupnodehours,
					100*groupnodehours/wallnodehours, groupjoules/kWh,
					groupnodes/groupjobs, groupnodehours/grouphours,
					grouphours/groupjobs, grouptimelimit/groupjobs/60,
					groupwait/groupjobs/3600, "")
	} else {

		# Per-group accounting

		# Print format
		if (tresgpu > 0)
			format = "%8s %8d  %10.1f  %7.2f %7.2f %9.2f %7.2f %7.2f %7.2f %7.2f\n"
		else
			format = "%8s %8d  %10.1f  %7.2f %7.2f %9.2f %7.2f %7.2f %7.2f\n"
		if (parsable > 0) format = gensub(/\s+/,"|","G",format) "\n" #TODO

		# Sort arrays by element values:
		# https://www.gnu.org/software/gawk/manual/html_node/Controlling-Scanning.html
		PROCINFO["sorted_in"] = "@ind_num_desc"

		for (group in groupname) {
			if (gr_jobs[group] > 0 && gr_wallcpu[group] > 0)
				if (tresgpu > 0)
					printf(format,
						groupname[group],
						gr_jobs[group],
						gr_wallnodes[group]/3600,
						100*gr_wallnodes[group]/(3600*wallnodehours),
						gr_nodes[group]/gr_jobs[group],
						gr_wallnodes[group]/gr_wallcpu[group],
						gr_wallcpu[group]/gr_jobs[group]/3600,
						gr_reqgpu[group]/gr_jobs[group],
						gr_timelimit[group]/gr_jobs[group]/60,
						gr_waittime[group]/gr_jobs[group]/3600,
						gr_perfectjobs[group],
						gr_jobs[group]-gr_perfectjobs[group],
						gr_wait30m[group], gr_wait1h[group], gr_wait2h[group], gr_wait3h[group], gr_wait6h[group], gr_wait12h[group],
						gr_wait1d[group], gr_wait2d[group], gr_wait3d[group], gr_wait5d[group], gr_wait7d[group],
						gr_nodes1[group],gr_nodes2[group],gr_nodes3[group],gr_nodes4[group],gr_nodes5[group],gr_nodesM[group])
				else
					printf(format,
						groupname[group],
						gr_jobs[group],
						gr_wallnodes[group]/3600,
						100*gr_wallnodes[group]/(3600*wallnodehours),
						gr_nodes[group]/gr_jobs[group],
						gr_wallnodes[group]/gr_wallcpu[group],
						gr_wallcpu[group]/gr_jobs[group]/3600,
						gr_timelimit[group]/gr_jobs[group]/60,
						gr_waittime[group]/gr_jobs[group]/3600,
						gr_perfectjobs[group],
						gr_jobs[group]-gr_perfectjobs[group],
						gr_wait30m[group], gr_wait1h[group], gr_wait2h[group], gr_wait3h[group], gr_wait6h[group], gr_wait12h[group],
						gr_wait1d[group], gr_wait2d[group], gr_wait3d[group], gr_wait5d[group], gr_wait7d[group],
						gr_nodes1[group],gr_nodes2[group],gr_nodes3[group],gr_nodes4[group],gr_nodes5[group],gr_nodesM[group])
		}
		if (tresgpu > 0)
			printf(format, "TOTAL", totaljobs, wallnodehours, 100,
				totalnodesaverage, nodesaverage, totalreqgpuaverage,
				totalwallaverage/3600, totaltimelimitaverage/60,
				totalwaitaverage/3600)
		else
			printf(format, "TOTAL", totaljobs, wallnodehours, 100,
				totalnodesaverage, nodesaverage,
				totalwallaverage/3600, totaltimelimitaverage/60,
				totalwaitaverage/3600)
	}
		
} ' | env LC_ALL=C sort -r -n -k $SORTCOLUMN -k 3 -k 1d >> $REPORT

# The sort command sorts number of running procs in descending order
# on keys $SORTCOLUMN and 3, and alphabetical sort on key 1
# The LC_ALL=C ensures that Upper case is sorted before lower case.

echo Report generated to file $REPORT

exit 0
